## Java基础
### 集合
- ArrayList: 初始化时是空数组，第一次调用add的时候初始化默认阈值为10，当size大于阈值时进行扩容，扩容至当前阈值的1.5倍
- HashMap
  - 链表长度默认阈值为8，当链表长度大于默认阈值时，检查数组是否大于64，如果小于64，只把数组扩容至当前大小的2倍，否则就将链表转化为红黑树
  - 当多线程操作HashMap的put时可能导致生成小童的hash key，最终导致数据覆盖
- ConcurrentHashMap：通过synchronized和CAS进行并发控制，如果添加Node时没有哈希冲突则用CAS控制并发，否则使用synchronized控制并发，每个链表/树一把锁
### 反射
可以在运行时分析和操作类的工具
### 多线程
- 线程死锁：线程A占用C资源请求D资源，线程B占用D资源请求C资源
- sleep和wait的区别：sleep不会释放锁，但是会调用后会自动恢复；wait会释放锁但是调用后不会自动恢复，除非配置了timeout时间
- synchronized
  - 可用于修饰方法、代码块
  - 原理：通过monitorenter和monitorexit命令标记同步代码范围并在执行的时候分别增减对象头中的锁计数器，当锁计数器为0时可以获取monitor对象，为1时不可获取
  - 锁升级与底层优化
    - 轻量级锁：轻度锁竞争，通过CAS进行锁操作
    - 自旋锁：轻度锁竞争尝试获取锁的时候，如果没获取到，先自旋再反复进行尝试，如果还是获取不到就挂起并转变为重量级锁，获取到了就执行代码
    - 锁消除：编译时如果检测到共享数据不存在多线程竞争，则会执行锁消除
    - 锁粗化：如果一系列操作都对同一个对象反复加解锁（例如循环），那么加锁范围就会扩展到这一系列操作的外部
  - synchronized和ReenTrantLock的对比：
    - 都是可重入锁
    - synchronized依赖JVM实现，ReenTrantLock依赖JDK实现
    - ReenTrantLock更灵活
    - synchronized为非公平锁，ReenTrantLock默认非公平锁，可自定义
    - synchronized不可中断，ReenTrantLock可以
- 线程池：
  - 好处：
    - 可重复利用线程资源
    - 方便管理线程
  - 重要参数：
    - corePoolSize：最小保留的线程数量。
    - maximumPoolSize：最大可以同时运行的线程数量。
    - workQueue：存放待执行任务的队列。
  - 饱和策略：
    - 抛exception拒绝新任务
    - 调用执行自己的线程处理任务
    - 直接丢弃新任务
    - 丢弃最早未处理的任务
  - 推荐通过构造函数创建线程池
  - 常用阻塞队列：
    - 容量为int最大值的有界阻塞队列LinkedBlockingQueue
    - 无容量不存储元素的同步队列SynchronousQueue
    - 按延迟时间长短对任务进行排序的延迟队列DelayedWorkQueue
    - 底层由数组实现，不可变更容量的有界阻塞队列ArrayBlockingQueue
  - 处理任务流程
    - 运行线程数 < 核心线程数 -> 创建新线程执行任务
    - 核心线程数 < 运行线程数 < 最大线程数 -> 把任务放进任务队列（如果队列已满，执行拒绝策略）
  - 线程池大小确定公式
    - CPU密集型：最大线程数=CPU核心数+1
    - I/O密集型：最大线程数=CPU核心数*2
- volatile
  - 作用
    - 保证变量的可见性（每次都从主内存中取值）
    - 防止指令重排序（通过插入特定的内存屏障来实现）
- ThreadLocal
  - 原理：将指定资源的副本存入访问它的线程下的ThreadLocalMap里
  - 内存泄漏问题原因：ThreadLocalMap使用的key是为ThreadLocal的弱引用，会出现key被GC但是value还在的情况，需要手动调用remove方法
- CAS
  - 优缺点
    - 比synchronized性能好
    - 重试次数过多会导致CPU开销过大
    - 不能保证代码块原子性
    - ABA问题（引入版本号解决）
  - 底层实现：操作系统实现
- AQS
  - Semaphore(信号量)：限制指定个数的线程可以访问共享数据，其余的等待，使用场景：限流
  - CountDownLatch(倒计时器)：当线程调用countDown直至state==0时，继续执行await方法之后的代码
  - CyclicBarrier(循环屏障)：当多个线程调用await方法直至数量满足预设count值时，执行预设任务
- 悲观锁/乐观锁
  - 悲观锁：适合多写场景，独占锁就是对应思想的实现
  - 乐观锁：适合多读场景，CAS就是对应思想的实现
### JVM
- 内存区域
  - 运行时数据区域
    - 线程共享：堆内存（包含字符串常量池）
    - 线程私有
      - 虚拟机栈、本地方法栈、程序计数器
  - 本地内存
    - 元空间（包含运行时常量池）
    - 直接内存
- 垃圾回收
  - 分代
    - 新生代：Eden空间、Survivor空间
    - 老年代
    - 元空间
  - 机制
    - 对象优先在Eden空间分配
    - 经过第一次Minor GC后转入Survivor空间
    - 大对象直接转入老年代
    - 长期存活对象（年龄到达阈值）也会被转入老年代
    - 老年代空间不够会触发Major GC
- 创建对象的过程
  - 类加载检查：遇到new指令，解析加载引用的类
  - 分配内存：在堆中分配内存
  - 初始化零值：根据类型为成员变量设置默认值
  - 设置对象头：在对象头中设置必要的信息
  - 执行init方法：执行代码中的构造函数等初始化方法
## 框架
### Spring
- IoC：统一创建并管理bean的Map
- AOP：基于动态代理用于通用功能构建的工具
- 声明Bean的注解：@Component/@Repository/@Service@Controller/Bean
- 注入Bean的注解：@Autowired/@Resource
- @Autowired/@Resource的区别：@Autowired默认按类型注入，@Resource默认按类名（首字母小写）注入
- 注入Bean的方式
  - 构造器
  - setter方法
  - 字段
- Bean的作用域
  - singleton：全局（ApplicationContext）单例bean
  - prototype：每次获取bean都创建新的
  - request：每次http请求都会创建新的，仅在当前request有效
  - session：每次http请求都会创建新的，仅在当前session有效
  - application：全局（ServletContext）单例bean
  - websocket：每次websocket会话创建新bean
- 单例Bean线程安全解决方法：使用ThreadLocal保存可变成员变量
- Bean生命周期
  - 实例化
  - 属性赋值
  - 初始化
    - 执行Aware接口的方法
    - 执行Processor接口的前置处理方法
    - 执行Initial接口的方法
    - 执行init-method方法
    - 执行Processor接口的后置处理方法
  - 销毁
    - 执行Dispose接口的方法
    - 执行detroy-method方法
- 如何解决循环依赖：通过三级缓存解决
  - 一级存放完成初始化的bean
  - 二级存放未属性填充的bean（可能为代理对象）
  - 三级存放ObjectFactory（保存了实例化bean）
  - 因为当涉及AOP场景时，ObjectFactory拿到的bean可能是代理对象，所以为了保证代理对象的单例属性，需要多一级缓存
- AOP常见通知类型
  - 前置通知
  - 后置通知
  - 返回通知
  - 异常通知
  - 环绕通知
- 事务
  - 特性
    - A：原子性
    - C：一致性
    - I：隔离性
    - D：持久性
  - 脏读：读到其他事务未提交的数据
  - 幻读：由于其他事务插入数据，导致同一事务前后查询出现不同情况
  - 不可重复读：由于其他事务修改数据，导致同一事务前后查询出现不同情况
- 隔离级别
  - 数据库默认
  - 读未提交
  - 读提交
  - 不可重复读
  - 序列化
- 默认事务传播行为：如果当前存在事务，则加入事务；不存在则创建新的事务
### Spring MVC
- 工作流程
  - DispatcherServlet拦截客户端请求
  - 调用HandlerMapping根据url查找对应的Handler
  - 调用HandlerAdapter执行Handler
  - Handler处理完请求返回model数据给DispatcherServlet
  - DispatcherServlet把model转成JSON格式返回给客户端
### Spring Boot
- 介绍：一套快速开发整合包
- 优点
  - 集成多种默认配置，开发效率高
  - 使用依赖注解方式的Java Config可以避免繁杂的XML配置
  - 内嵌HTTP服务器，方便开发和测试Web程序
- Starter：服务于特定功能并处理好依赖关系的封装包
- 自动装配原理
  - 通过注解开启自动装配，通过Factory Loader加载factory配置文件中的自动配置类实现自动装配
### Mybatis
- #{}和${}的区别
  - #{}：预编译处理
  - ${}: 字符串替换
- Dao接口工作原理：通过JDK动态代理为Dao接口生成代理对象然后拦截接口方法并执行sql
- 为什么说MyBatis是半自动ORM映射工具？它与全自动的区别在哪里？
  - 全自动ORM会将数据库表与Java对象完全关联上，无需写sql即可查询对象信息，例如Hibernate；而Mybatis需要手动写sql完成这样的功能
## 数据库
### MySQL

- InnoDB存储引擎特点
  - 支持行级锁和表级锁，默认行级锁
  - 支持事务，实现了4个隔离级别
  - 支持数据库异常崩溃后的安全恢复，依赖redo log
  - 支持MVCC
- MVCC
  - 通过创建数据的多个版本和使用快照读取来实现并发控制
  - 读操作使用旧版本数据的快照，写操作创建新版本
  - 只在读提交和可重复度两种隔离级别下工作
- 索引
  - 优点
    - 提高查询速度
  - 缺点
    - 创建和维护索引需要耗费资源
  - 底层结构：B+树，多路平衡查找树
    - 特点
      - 只有叶子结点存放key和data，其他内结点只存放key（IO次数更少）
      - 叶子结点有一条引用链指向与它相邻的叶子结点（方便范围查找）
      - 任何查找都是从根结点到叶子结点的过程（查询效率稳定）
  - 类型
    - 按存储方式划分
      - 聚簇索引（主键索引）
      - 非聚簇索引
    - 按应用划分
      - 主键索引
      - 普通索引
      - 唯一索引
      - 联合索引
      - 全文索引
  - 失效情况
    - 查询条件未遵守最左匹配原则
    - like以%开头
    - 发生隐式转化
      - 对索引列进行计算/函数处理/类型转换
      - 查询条件中有OR且条件之一没有索引
      - IN的取值范围较大
  - 一条查询SQL的执行过程
    - 检查权限
    - 词法分析
    - 优化执行方案
    - 调用引擎执行
  - 一条更新SQL的执行过程
    - 查询数据流程
    - 通过二阶段提交更新数据（prepare redo log -> 记录binlog -> commit redo log）
- 三大日志
  - binlog（归档日志）：记录所有涉及更新数据的逻辑操作，并且是顺序写，用来保证数据一致性
  - redo log（重做日志）：用于崩溃恢复，记录了数据更新的信息
    - 二阶段提交：prepare redo log -> 记录binlog -> commit redo log
  - undo log（回滚日志）：记录事务修改数据的信息，用于事务回滚的情况
### Redis
- 为什么快
  - 基于内存
  - 单线程事件处理模型+IO多路复用
  - 内置多种优化过后的数据类型
  - 通信协议实现简单且解析高效
- 为什么用Redis
  - 高性能：操作内存更快
  - 高并发：操作缓存数据能够承受更多的请求
  - 功能多：除了缓存还可用于分布式锁等场景
- 常见数据结构
  - String：常规计数
  - Hash：存储用户信息
  - List：消息列表
  - Set：不重复列表
  - Sorted Set：排行榜
    - 底层数据结构：跳表
- 过期键删除策略：定期删除+惰性删除
- 内存淘汰机制
  - LRU机制，选最近最少使用的数据淘汰
  - 选将要过期的数据淘汰
  - 随机淘汰
  - 当内存不足时，移除最近最少使用的key
  - 不淘汰数据，内存不足时，写数据会报错
  - 从数据集中淘汰最不经常使用的数据
- 持久化机制
  - RDB：快照持久化，灾备能力强，数据恢复快
  - AOF：实时增量持久化，安全性强
  - 通常开启RDB+AOF混合持久化
- 大量key集中过期
  - 给key设置随机过期时间
  - 开启惰性删除
- 大key：key对应的value占用内存较大
  - 如何处理大key
    - 分割大key
    - 手动清理
    - 采用合适的数据结构避免出现大key
    - 开启惰性删除
- 热key：被访问次数明显多于其他的key
  - 如何处理热key
    - 读写分离
    - 分散数据至多个节点
    - 采用二级缓存方式，设置本地缓存
- 生产问题
  - 缓存雪崩：缓存同一时间大面积失效
    - 解决方案
      - 保证集群高可用
      - 选择合适的内存淘汰策略
      - 提前预热热点数据
  - 缓存穿透：大量请求的key不在缓存中
    - 解决方案
      - 用布隆过滤器提前缓存可能请求的key
  - 缓存击穿：大量热点数据不在缓存中
    - 解决方案
      - 提前缓存热点数据
## 中间件
### Kakfa
- 是一个分布式流式处理平台，也可用作消息队列
- 特点
  - 高吞吐量、低延迟：每秒可处理十万级消息，毫秒级延迟
  - 扩展性强、容错性高：支持集群扩展，部分节点故障不影响整体，容错高
  - 支持持久化和备份：消息会持久化到磁盘并支持备份
  - 高并发：支持多客户端同时读写
- 为什么快
  - 顺序写入优化，减少IO时间
  - 支持批量处理，减少网络和IO开销
  - 可直接将数据从磁盘发送到网络套接字，避免了用户空间和内核空间之间的多次数据拷贝
  - 支持对数据进行压缩
- 多分区和多副本的好处
  - 多分区可以用用负载均衡，提高并发能力
  - 多副本提高灾备能力
- 如何保证消息的消费顺序
  - 每次添加消息到分区都采用尾加法，设置特定的offset来保证顺序
- 如何保证消息不丢失
  - 生产者丢失消息：设置消息发送重试
  - 消费者丢失消息：手动提交offset
  - kafka弄丢了消息：合理配置参数保证服务的高可用