## 基础架构
![](vx_images/88253421240554.png)
- `连接器`：身份认证和权限相关(登录 MySQL 的时候)。
- `查询缓存`：执行查询语句的时候，会先查询缓存（MySQL 8.0 版本后移除，因为这个功能不太实用）。
- `分析器`： 分析SQL 语句要干嘛，再检查SQL 语句语法是否正确。
- `优化器`： 按照 MySQL 认为最优的方案去执行。
- `执行器`： 执行语句，然后从存储引擎返回数据。 执行语句之前会先判断是否有权限，如果没有权限的话，就会报错。
- `插件式存储引擎`：主要负责数据的存储和读取，采用的是插件式架构，支持 InnoDB、MyISAM、Memory 等多种存储引擎。
## 存储引擎
### InnoDB存储引擎的特点
- 支持行级锁(row-level locking)和表级锁,默认为行级锁。
- 支持事务，实现了 SQL 标准定义了四个隔离级别，具有提交(commit)和回滚(rollback)事务的能力。
- 支持外键。
- 支持数据库异常崩溃后的安全恢复，依赖于`redo log`。
- 支持MVCC(Multiversion Concurrency Control)。应对高并发事务，MVCC比单纯的加锁更高效；MVCC 通过创建数据的多个版本和使用快照读取来实现并发控制。读操作使用旧版本数据的快照，写操作创建新版本，并确保原始版本仍然可用。这样，不同的事务可以在一定程度上并发执行，而不会相互干扰，从而提高了数据库的并发性能和数据一致性。MVCC只在`READ COMMITED`和`REPEATABLE READ`两个隔离级别下工作。
## 索引
索引是一种用于快速查询和检索数据的数据结构。在 MySQL 中，无论是 Innodb 还是 MyIsam，都使用了 B+树作为索引结构。
### 优缺点
#### 优点
- 使用索引可以大大加快数据的检索速度（大大减少检索的数据量）, 减少 IO 次数，这也是创建索引的最主要的原因。
- 通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。
#### 缺点
- **创建索引和维护索引需要耗费许多时间**：当对表中的数据进行增删改的时候，如果数据有索引，那么索引也需要动态的修改，会降低SQL执行效率。
- **占用物理存储空间**：索引需要使用物理文件存储，也会耗费一定空间。
### B+树
全称为**多路平衡查找树**。
#### 特点
- 只有叶子节点存放key和data，其他内节点只存放key（IO次数更少）。
- 叶子节点有一条引用链指向与它相邻的叶子节点（方便范围查询）。
- 任何查找都是从根结点到叶子节点的过程（查询效率稳定）。
### 索引类型
#### 按照底层存储方式角度划分
- **聚簇索引（聚集索引）**：索引结构和数据一起存放的索引，InnoDB 中的主键索引就属于聚簇索引。
- **非聚簇索引（非聚集索引）**：索引结构和数据分开存放的索引，二级索引(辅助索引)就属于非聚簇索引。
#### 按照应用维度划分
- **主键索引**：加速查询 + 列值唯一（不可以有 NULL）+ 表中只有一个。
- **普通索引**：仅加速查询。
- **唯一索引**：加速查询 + 列值唯一（可以有 NULL）。
- **覆盖索引**：一个索引包含（或者说覆盖）所有需要查询的字段的值。
- **联合索引**：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并。(满足最左前缀匹配原则)
    - 最左前缀匹配原则：指的是在使用联合索引时，MySQL 会根据索引中的字段顺序，从左到右依次匹配查询条件中的字段。如果查询条件与索引中的最左侧字段相匹配，那么 MySQL 就会使用索引来过滤数据，这样可以提高查询效率。最左匹配原则会一直向右匹配，直到遇到范围查询（如 >、<）为止。对于 >=、<=、BETWEEN 以及前缀匹配 LIKE 的范围查询，不会停止匹配。
- **全文索引**：对文本的内容进行分词，进行搜索。目前只有 CHAR、VARCHAR ，TEXT 列上可以创建全文索引。一般不会使用，效率较低，通常使用搜索引擎如 ElasticSearch 代替。
###  索引失效的几种情况
- 创建了复合索引但查询条件未遵守最左前缀匹配原则。
- like以%开头。
-发生隐式转换。
- 在索引列上进行计算、函数、类型转换等操作。
- 查询条件中使用 OR，且 OR 的前后条件中有一个列没有索引，涉及的索引都不会被使用到。
- IN 的取值范围较大时会导致索引失效。
### 正确使用索引的一些建议
- 选择合适的字段创建索引：
    - 不为 NULL 的字段。
    - 被频繁查询的字段。
    - 被作为条件查询的字段。
    - 频繁需要排序的字段。
    - 被经常频繁用于连接的字段。
- 被频繁更新的字段应该慎重建立索引。
- 限制每张表上的索引数量，建议单张表索引不超过 5 个。
- 尽可能的考虑建立联合索引而不是单列索引。
- 字符串类型的字段使用前缀索引代替普通索引，前缀索引仅限于字符串类型，较普通索引会占用更小的空间。
## 一条SQL语句在MySQL中如何执行的
### 查询语句
```SQL
update tb_student A set A.age='19' where A.name=' 张三 ';
```
- 先检查该语句是否有权限，如果没有权限，直接返回错误信息。（检查权限）
- 通过分析器进行词法分析，提取 sql 语句的关键元素。然后判断这个 sql 语句是否有语法错误。（词法分析）
- 那么优化器根据自己的优化算法进行选择执行效率最好的一个执行方案。（优化执行方案）
- 进行权限校验，如果没有权限就会返回错误信息，如果有权限就会调用数据库引擎接口，返回引擎的执行结果。（调用引擎执行）
#### 简化版
- 检查权限
- 词法分析
- 优化执行方案
- 调用引擎执行
### 更新语句
```SQL
update tb_student A set A.age='19' where A.name=' 张三 ';
```
- 先查询到张三这一条数据。（查询数据）
- 然后拿到查询的语句，把 age 改为 19，然后调用引擎 API 接口，写入这一行数据，InnoDB 引擎把数据保存在内存中，同时记录 redo log，此时 redo log 进入 prepare 状态，然后告诉执行器，执行完成了，随时可以提交。（数据保存内存->记录redo log->记录binlog->提交redo log）
- 执行器收到通知后记录 binlog，然后调用引擎接口，提交 redo log 为提交状态。
- 更新完成。
#### 简化版
- 查询数据流程
- 通过二阶段提交更新数据（prepare redo log->记录binlog-> commit redo log）
## explain执行计划中要重点关注哪些要素
![](_v_images/20200415223430111_18456.png)
`type`的几种结果：
![](_v_images/20200415223609621_14235.png)
Extra列中需要注意出现的几种情况：
![](_v_images/20200415223702446_13869.png)
## 事务
### 特性（ACID）
- 原子性（A）：事务最小，不可分割，动作要么全部完成，要不完全不起作用
- 一致性（C）：执行事务前后，数据保持一致
- 隔离性（I）：并发事务之间相互独立
- 持久性（D）：事务提交后，对数据库中数据的改变是持久的
### 脏读、幻读、不可重复读
- 脏读：一个事务读取了另一个事务未提交的数据
- 幻读：同一事务中前后分别执行相同的查询时，由于中间其他事务**插入**了新的数据，导致后续的查询返回了额外的数据。
- 不可重复读：同一事务中前后分别执行相同的查询时，由于中间其他事务**修改**了数据，导致后续的查询结果不同。
### 事务隔离级别
- READ-UNCOMMITTED（读取未提交）：最低的隔离级别，**允许读取尚未提交的数据变更**，可能会导致**脏读、幻读或不可重复读**。
- READ-COMMITTED（读取已提交）：**允许读取并发事务已经提交的数据**，可以**阻止脏读**，但是**幻读或不可重复读**仍有可能发生。
- REPEATABLE-READ（可重复读）：**对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改**，可以**阻止脏读**，但**幻读**仍有可能发生。
- SERALIZABLE（可串行化）：最高的隔离级别，完全服从ACID的隔离级别。**所有的事务依次逐个执行**，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止**脏读、不可重复读以及幻读**。

|     隔离级别      | 脏读 | 不可重复读 | 幻读 |
| ---------------- | ---- | --------- | ---- |
| READ-UNCOMMITTED | ✔   | ✔        | ✔   |
| READ-COMMITTED   | ✘   | ✔        | ✔   |
| REPEATABLE-READ  | ✘   | ✘        | ✔   |
| SERIALIZABLE     | ✘   | ✘        | ✘   |
因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是**READ-COMMITTED**，但是**InnoDB存储引擎**默认使用**REPEATABLE-READ**并不会有任何性能损失。
InnoDB存储引擎在**分布式事务**的情况下一般会用到**SERIALIZABLE**隔离级别。
## MySQL三大日志
### binlog（归档日志）
binlog 是逻辑日志，会记录所有涉及更新数据的逻辑操作，并且是顺序写，用来保证数据一致性。
### redo log（重做日志）
redo log（重做日志）是 InnoDB 存储引擎独有的，它让 MySQL 拥有了崩溃恢复能力。
MySQL 中数据是以页为单位，你查询一条记录，会从硬盘把一页的数据加载出来，加载出来的数据叫数据页，会放入到 `Buffer Pool` 中。后续的查询都是先从 `Buffer Pool` 中找，没有命中再去硬盘加载，减少硬盘 IO 开销，提升性能。更新表数据的时候，也是如此，发现 `Buffer Pool` 里存在要更新的数据，就直接在 `Buffer Pool` 里更新。然后会把“在某个数据页上做了什么修改”记录到重做日志缓存（`redo log buffer`）里，接着刷盘到 redo log 文件里。
查询数据：先查询redo log**数据缓存池**，没有再从硬盘加载
更新数据：先更新**数据缓存池**，然后记录**redo log缓存**，再刷盘到redo log文件
#### 刷盘时机
- 事务提交。
- log buffer 空间不足时。
- 事务日志缓冲区（transaction log buffer）满时。
-  定期会执行Checkpoint（检查点）操作时。
- 后台刷新线程周期性刷盘数据时。
- 正常关闭服务器。
#### 刷盘策略
- **0**（默认）：设置为 0 的时候，表示每次事务提交时不进行刷盘操作。这种方式性能最高，但是也最不安全，因为如果 MySQL 挂了或宕机了，可能会丢失最近 1 秒内的事务。
- **1**：设置为 1 的时候，表示每次事务提交时都将进行刷盘操作。这种方式性能最低，但是也最安全，因为只要事务提交成功，redo log 记录就一定在磁盘里，不会有任何数据丢失。
- **2**：设置为 2 的时候，表示每次事务提交时都只把 log buffer 里的 redo log 内容写入 page cache（文件系统缓存）。page cache 是专门用来缓存文件的，这里被缓存的文件就是 redo log 文件。这种方式的性能和安全性都介于前两者中间。
### 两阶段提交
redo log（重做日志）让 InnoDB 存储引擎拥有了崩溃恢复能力。
binlog（归档日志）保证了 MySQL 集群架构的数据一致性。
虽然它们都属于持久化的保证，但是侧重点不同。
在执行更新语句过程，会记录 redo log 与 binlog 两块日志，以基本的事务为单位，redo log 在事务执行过程中可以不断写入，而 binlog 只有在提交事务时才写入，所以 redo log 与 binlog 的写入时机不一样。
将 redo log 的写入拆成了两个步骤`prepare`和`commit`，这就是**两阶段提交**。
提交顺序：redo log prepare -> binlog write -> redo log commit
### undo log（回滚日志）
每一个事务对数据的修改都会被记录到 undo log ，当执行事务过程中出现错误或者需要执行回滚操作的话，MySQL 可以利用 undo log 将数据恢复到事务开始之前的状态。
undo log 属于逻辑日志，记录的是 SQL 语句，比如说事务执行一条 DELETE 语句，那 undo log 就会记录一条相对应的 INSERT 语句。同时，undo log 的信息也会被记录到 redo log 中，因为 undo log 也要实现持久性保护。并且，undo-log 本身是会被删除清理的，例如 INSERT 操作，在事务提交之后就可以清除掉了；UPDATE/DELETE 操作在事务提交不会立即删除，会加入 history list，由后台线程 purge 进行清理。
### MVCC
- InnoDB在`Repeatable Read` 和 `Read Committed` 两个隔离级别下，对普通`select`语句会使用非锁定读，即读取行的快照数据，又叫快照读。
- 当执行`insert`/`update`/`delete`/`for update`语句时，会使用锁定读，对读到的记录加锁。
#### InnoDB对MVCC的实现
`MVCC` 的实现依赖于：**隐藏字段、Read View、undo log**。在内部实现中，`InnoDB` 通过数据行的**事务id**和`Read View`（事务管理View）来判断数据的可见性，如不可见，则通过数据行的**回滚指针**找到 `undo log` 中的历史版本。