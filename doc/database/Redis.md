## 简介
一个被广泛应用于缓存，将数据存在内存中的NoSQL数据库。
## Redis为什么快
- Redis 基于内存，内存的访问速度比磁盘快很多。
- Redis 基于 Reactor 模式设计开发了一套高效的事件处理模型，主要是单线程事件循环和 IO 多路复用。
- Redis 内置了多种优化过后的数据类型/结构实现，性能非常高。
- Redis 通信协议实现简单且解析高效。
### 简化版
- 基于内存
- 单线程事件处理模型+IO多路复用
- 内置多种优化过后的数据类型
- 通信协议实现简单且解析高效
## 为什么要用 Redis
- 高性能：Redis作为缓存数据库是将数据存在内存中的，操作内存要比操作数据库的本地持久化数据要快。
- 高并发：直接操作缓存能够承受的请求是远远大于直接访问数据库的，尤其是热门的待读数据，所以通常将这些数据存入缓存。
- 功能多：除了缓存，还可用于分布式锁等场景。
## Redis 除了做缓存，还能做什么
- 分布式锁：通常情况下，我们都是基于 Redisson 来实现分布式锁。
- 延时队列：Redisson 内置了延时队列（基于 Sorted Set 实现的）。
- 分布式 Session ：利用 String 或者 Hash 数据类型保存 Session 数据，所有的服务器都可以访问。
- 复杂业务场景：通过 Redis 以及 Redis 扩展（比如 Redisson）提供的数据结构，我们可以很方便地完成很多复杂的业务场景比如通过 Bitmap 统计活跃用户、通过 Sorted Set 维护排行榜。
## Redis 的线程模型
单线程事件处理器+ IO 多路复用机制（事件驱动，来哪个消息处理哪个）。
## Redis 多线程
### Redis 6.0前为什么不用多线程
- 单线程编程更易维护，多线程更复杂且可能会影响性能。
- redis性能瓶颈不在CPU，而在内存和网络。
### Redis 6.0之后为什么引用多线程
为了提高网络IO读写性能。
## Redis 常见数据结构以及使用场景分析
- String数据结构是简单的key-value类型，value其实不仅可以是String，也可以是数字。
    - 应用场景：常规计数：微博数，粉丝数等。
- Hash：hash 是一个 string 类型的 field 和 value 的映射表，hash 适合用于存储需要频繁改动部分字段的对象，后续操作的时候，你可以直接仅仅修改这个对象中的某个字段的值。
    - 应用场景：存储用户信息，商品信息等等。
- List： Redis list 的实现为一个双向链表，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销。
    - 应用场景：比如微博的关注列表，粉丝列表，消息列表等功能。
- Set： 不重复list。
    - 应用场景：同关注、共同粉丝、共同喜好等功能。
- Sorted Set：和set相比，sorted set增加了一个权重参数score，使得集合中的元素能够按score进行有序排列。底层实现是跳表。
    - 应用场景：在直播系统中，实时排行信息包含直播间在线用户列表，各种礼物排行榜，弹幕消息（可以理解为按消息维度的消息排行榜）等信息。
    - 跳表的优点
	    - 节省内存。
	    - 实现简单。
## Redis过期键的删除策略
Redis 采用的是 定期删除+惰性/懒汉式删除 结合的策略，这也是大部分缓存框架的选择。定期删除对内存更加友好，惰性删除对 CPU 更加友好。两者各有千秋，结合起来使用既能兼顾 CPU 友好，又能兼顾内存友好。
- 定期删除：redis默认是每隔 100ms 就随机抽取一些设置了过期时间的key，检查其是否过期，如果过期就删除。
- 懒惰删除：放任键过期不管，但是每次从键空间中获取键时，都检查取得的键是否过期，如果过期的话，就删除该键;如果没有过期，就返回该键。
## Redis 6种内存淘汰机制
- volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰
- volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰
- volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰
- allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key（这个是最常用的）
- allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰
- no-eviction（默认）：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。
- volatile-lfu（least frequently used）：从已设置过期时间的数据集（server.db[i].expires）中挑选最不经常使用的数据淘汰。
- allkeys-lfu（least frequently used）：从数据集（server.db[i].dict）中移除最不经常使用的数据淘汰。
## Redis 持久化机制
- 快照（snapshotting）持久化（RDB）：Redis可以通过创建快照来获得存储在内存里面的数据在某个时间点上的副本。Redis创建快照之后，可以对快照进行备份，可以将快照复制到其他服务器从而创建具有相同数据的服务器副本（Redis主从结构，主要用来提高Redis性能），还可以将快照留在原地以便重启服务器的时候使用。
- AOF（append-only file）持久化：与快照持久化相比，AOF持久化 的实时性更好，因此已成为主流的持久化方案。默认情况下Redis没有开启AOF（append only file）方式的持久化，可以通过appendonly参数开启：`appendonly yes`，开启AOF持久化后每执行一条会更改Redis中的数据的命令，Redis就会将该命令写入硬盘中的AOF文件。
### RDB和AOF的优缺点
- RDB灾备能力强，数据恢复快。
- AOF数据安全性强。
- 通常默认使用RDB，当对数据安全性要求较高时，通常开启RDB和AOF混合持久化。
## Redis 事务
Redis 通过 MULTI、EXEC、WATCH 等命令来实现事务(transaction)功能。事务提供了一种将多个命令请求打包，然后一次性、按顺序地执行多个命令的机制，并且在事务执行期间，服务器不会中断事务而改去执行其他客户端的命令请求，它会将事务中的所有命令都执行完毕，然后才去处理其他客户端的命令请求。
### Redis 事务支持原子性吗？
Redis 事务是不支持回滚（roll back）操作的。因此，Redis 事务其实是不满足原子性的。
### Redis 事务支持持久性吗？
Redis虽然支持数据持久性，但是由于实时性较好的AOF持久化存在数据丢失或者性能较差的问题，不能保证事务的持久性。
## Redis性能优化
### 使用批量操作减少网络传输
通过使用原生批量操作的命令/pipeline/Lua脚本批量执行命令来减少网络传输，提高性能。
### 大量Key集中过期问题
- 给key设置随机过期时间
- 开启惰性删除
### 大Key
当一个key对应的value占用的内存较大时，这个key就可以看作大key。
#### 如何处理大key？
- 分割大key为多个小key。
- 手动使用命令清理。
- 采用合适的数据结构避免出现大key。
- 开启惰性删除。
### 热key
当一个key被访问次数明显多于其他key时，这个key就可以看作热key。
热key会占用大量的资源影响Redis对其他请求的正常处理。
#### 如何处理热key？
- 读写分离。
- 将热点数据分散存储在多个Redis节点上。
- 采用二级缓存的方式，将热key存一份到JVM本地内存中。
### 慢查询命令
可以通过`SLOWLOG GET`的命令查询。
## 生产问题
### 缓存雪崩
- 描述：缓存同一时间大面积的失效，所以，后面的请求都会落到数据库上，造成数据库短时间内承受大量请求而崩掉。
- 解决方案：
    - 尽量保证整个 redis 集群的高可用性，发现机器宕机尽快补上。选择合适的内存淘汰策略。
    - 针对热点数据提前预热。
### 缓存穿透
- 描述：就是大量请求的 key 根本**不存在于缓存和数据库**中，导致请求直接到了数据库上，根本没有经过缓存这一层。
- 解决方案：把所有可能存在的请求的值都存放在布隆过滤器中，当用户请求过来时，用布隆过滤器过滤无效key，有效key则按正常流程操作。
### 缓存击穿
- 描述：大量热点数据不存在于缓存中，导致请求直接到了数据库上。
- 解决方案：提前把热点数据放入缓存中进行预热。
## 缓存常用的3种读写策略
### Cache Aside Pattern（旁路缓存模式）
Cache Aside Pattern是我们平时使用比较多的一个缓存读写模式，比较适合**读请求比较多**的场景。
- 先更新 db
- 然后直接删除 cache
#### 缺陷
- 首次请求数据一定不在cache的问题
    - 解决办法：可以将热点数据提前放入cache中。
- 写操作比较频繁的话导致cache中的数据会被频繁删除，这样会影响缓存命中率。
    - 解决办法：
        - 数据库和缓存数据强一致场景：更新DB的时候同样更新cache，不过我们需要加一个锁/分布式锁来保证更新cache的时候不存在线程安全问题。
        - 可以短暂地允许数据库和缓存数据不一致的场景：更新DB的时候同样更新cache，但是给缓存加一个比较短的过期时间，这样的话就可以保证即使数据不一致，影响也比较小。
### Read/Write Through Pattern（读写穿透）
Read/Write Through Pattern中服务端把cache视为主要数据存储，从中读取数据并将数据写入其中。cache服务负责将此数据读取和写入DB，从而减轻了应用程序的职责。
这种缓存读写策略在平时的开发过程中非常少见。抛去性能方便的影响，大概率是因为我们经常使用的分布式缓存Redis并没有提供cache将数据写入DB的功能。
#### 写（Write Through）
- 先查cache，cache中不存在，直接更新DB。
- cache中存在，则先更新cache，然后cache服务自己更新DB（同步更新cache和DB）。
#### 读（Read Through）
- 从cache中读取数据，读取到就直接返回。
- 读取不到的话，先从DB加载，写入到cache后返回响应。
#### 缺陷
- 首次请求数据一定不在cache。
### Write Behind Pattern（异步缓存写入）
Write Behind Pattern只直接更新缓存，不直接更新DB，而是改为异步批量的方式更新DB。
很明显，这种方式对数据一致性带来了更大的挑战，比如cache数据可能还没异步更新DB的话，cache服务可能就挂掉了。
#### 应用场景
- 消息队列中消息的异步写入磁盘
- MySQL的InnoDB Buffer Pool的机制
- 一些数据经常变化又对数据一致性要求没那么高的场景，比如浏览量、点赞量。
