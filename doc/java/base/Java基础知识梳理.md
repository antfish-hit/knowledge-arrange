# Java基础知识梳理
尽量以简练而精确的内容对Java基础知识[^1]进行再梳理。

## 面向过程和面向对象的区别

   - 面向过程: 性能高
   - 面向对象: 易维护、易复用、易扩展

## Java语言特点

   - 面向对象（封装、继承、多态）
   - 跨平台
   - 支持多线程
   - 相对安全（没有指针，有垃圾回收器）
   - 支持网络编程且简便
   - 编译与解释并存

## 什么是JVM
运行Java字节码的虚拟机，有针对不同系统的特定实现

## Java和C++的区别

   - 都是面向对象
   - Java不提供指针来直接访问内存
   - Java类是单继承，C++是多继承，Java接口是多继承
   - Java有垃圾回收器，自动管理内存

## 基本数据类型占用内存列表
![内存](_v_images/20191211204001886_30728.jpg)

## 重载与重写的区别

   - 重载：方法名相同，参数列表不同。
   - 重写：方法名相同，参数列表也相同，返回值和抛出异常的范围小于父类，访问修饰符大于父类。

## 封装、继承、多态

   - 封装：隐藏具体实现，只对外提供**调用接口(函数)**
   - 继承：代码复用
   - 多态：接口的多种不同的实现方式，即父类类型引用指向子类类型实例

## String为什么是不可变的
String类中使用final关键字修饰字符数组来保存字符串

## StringBuffer和StringBuilder的区别
StringBuffer对方法加了同步锁，是线程安全的，而StringBuilder没有

## 接口和抽象类的区别(JDK<=1.8)

   - 接口方法默认是public的，所有方法不能有实现（Java 8开始可以有默认实现），抽象类可以有非抽象的方法。
   - 接口中变量默认是static final的。
   - 一个类可以实现多个接口，但只能继承一个抽象类。
   - 从设计层面来说，抽象是一种模板设计，接口则是一种行为规范。
   - 在JDK8中，接口也可以定义静态方法，可以直接用接口名调用。实现类和实现是不可以调用的。如果同时实现两个接口，接口中定义了一样的默认方法，则必须重写，不然会报错

## 成员变量和局部变量的区别

   - 成员变量可以被public、private、static登修饰符修饰，局部变量不行；两者都能被final修饰
   - 从变量在内存中的存储方式来看：如果成员变量用static修饰，则是属于类的，反之属于实例，对象存在堆内存，局部变量则存在栈内存。
   - 成员变量是对象的一部分，局部变量随着方法的调用而自动消失。
   - 成员变量没有初值的话，会被按照类型赋予默认值，局部变量则不会。

## 静态方法与实例方法的区别

   - 静态方法属于类，实例方法属于对应的实例。
   - 静态方法不能访问实例成员和实例方法，实例方法无限制。

## ==和equals的区别

   - 对于基本类型，==比较值，对于引用类型，==比较内存地址。
   - 类没有重写equals时等价于==。

## hashCode()和equals()

   - equals返回true时，hashCode的返回值也必须相同 。
   - hashCode的返回值相同不代表equals返回true。
   - 重写了equals就必须重写hashCode()。

## Java中只有值传递

## 程序 > 进程 > 线程

## 线程基本状态
![JDK](_v_images/20191211210026595_16965.png)

## 线程的生命周期
   ![Java线程状态变迁](_v_images/20191203211343516_9129.png)

## final关键字

   - 修饰基本类型的变量时，数值一旦初始化就不能更改；修饰引用类型的变量时，一旦初始化就不能再指向其他对象。
   - 修饰类时表示类不能被继承，且所有成员方法都会被隐式的指定为final方法。
   - 修饰方法时方法不能被重写。

## Java异常类层次结构
   ![Exception](_v_images/20191203211518938_26681.png)

## finally块不会执行的特殊情况

   - 在finally块第一行发生了异常。
   - 在异常语句前用了`System.exit(int)`已退出程序。
   - 程序所在的线程死亡。
   - 关闭CPU。

## 当try语句和finally语句中都有return语句时，忽略try中的return而执行finally的。

## 可以使用`transient`关键字阻止序列化变量。

## Java IO流

   - 按流向分：输入和输出流
   - 按操作单元分：字节流和字符流
   - 按流的角色分：节点流和处理流

      ![IO-操作方式分类](_v_images/20191203211550972_5337.png)
      ![IO-操作对象分类](_v_images/20191203211614843_12834.png)

## BIO/NIO/AIO的区别

   |             | BIO      | NIO          | AIO            |
   | ----------- | -------- | ------------ | -------------- |
   | 同步/异步   | 同       | 同           | 异             |
   | 阻塞/非阻塞 | 阻       | 非           | 非             |
   | 场景        | 连接数少 | 高并发性能好 | 暂时应用不广泛 |

## 浅拷贝和深拷贝的区别
  - 浅拷贝：基础类型复制值，引用类型复制引用中保存的内存地址
  - 深拷贝：基础类型复制值，引用类型复制引用指向的对象(其包含的所有数据)

[^1]: [Java 基础知识回顾](https://snailclimb.gitee.io/javaguide/#/docs/java/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86)