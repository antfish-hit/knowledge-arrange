# HashMap

1. HashSet底层是基于HashMap实现的，区别：

   |             HashMap              |                           HashSet                            |
   | :------------------------------: | :----------------------------------------------------------: |
   |          实现了Map接口           |                         实现Set接口                          |
   |            存储键值对            |                          仅存储对象                          |
   |   调用 `put()`向map中添加元素    |               调用 `add()`方法向Set中添加元素                |
   | HashMap使用键（Key）计算Hashcode | HashSet使用成员对象来计算hashcode值，对于两个对象来说hashcode可能相同，所以equals()方法用来判断对象的相等性， |

2. Jdk1.8之前`HashMap` 底层是 **数组和链表** 结合在一起使用也就是 **链表散列**。**HashMap 通过 key 的 hashCode 经过扰动函数处理过后得到 hash 值，然后通过 (n - 1) & hash 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。**

3. 所谓**扰动函数**指的就是 **HashMap 的 hash 方法。使用 hash 方法也就是扰动函数是为了防止一些实现比较差的 hashCode() 方法 换句话说使用扰动函数之后可以减少碰撞**。

4. 所谓 **“拉链法”** 就是：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。

5. 在HashMap中，哈希桶数组table的长度length大小必须为2的n次方(一定是合数)，这是一种非常规的设计，常规的设计是把桶的大小设计为素数。相对来说素数导致冲突的概率要小于合数。HashMap采用这种非常规设计，主要是为了在取模和扩容时做优化，同时为了减少冲突，HashMap定位哈希桶索引位置时，也加入了高位参与运算的过程。

6. HashMap定位哈希桶索引位置的算法本质：**取key的hashCode值、高位运算、取模运算**。

   ![](../../../../assert/java/base/collections/HashMap-hash.png)

7. HashMap的put方法：

   ![](../../../../assert/java/base/collections/HashMap-put.png)

   1. 判断键值对数组`table[i]`是否为空或为`null`，否则执行`resize()`进行扩容；
   2. 根据键值`key`计算`hash`值得到插入的数组索引i，如果`table[i] == null`，直接新建节点添加，转向f，如果`table[i]`不为空，转向c；
   3. 判断`table[i]`的首个元素是否和`key`一样，如果相同直接覆盖`value`，否则转向d，这里的相同指的是`hashCode`以及`equals`；
   4. 判断`table[i]`是否为`treeNode`，即`table[i]`是否是红黑树，如果是红黑树，则直接在树中插入键值对，否则转向e；
   5. 遍历`table[i]`，判断链表长度是否大于8，大于8的话把链表转换为红黑树，在红黑树中执行插入操作，否则进行链表的插入操作；遍历过程中若发现`key`已经存在直接覆盖`value`即可；
   6. 插入成功后，判断实际存在的键值对数量`size`是否超多了最大容量的`threshold`，如果超过，进行扩容。

