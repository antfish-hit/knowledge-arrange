# Java内存知识梳理

1. Java虚拟机在执行Java程序的过程中会把它管理的内存 划分成若干个不同的数据区域。

   线程私有的：

   - 程序计数器
   - 虚拟机栈
   - 本地方法栈

   线程共享的：

   - 堆
   - 方法区
   - 直接内存

2. 程序计数器是一块较小的内存空间，可以看做是当前线程所执行的字节码的**行号指示器**。**字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令**。

   作用：

   - 字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制。
   - 在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道执行命令的位置。

   注意：**程序计数器是唯一一个不会出现OutOfMemoryError的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡**。

3. Java内存可以粗糙的区分为**堆内存(Heap)**和**栈内存(Stack)**，其中栈就是虚拟机栈，或者说是**虚拟机栈中局部变量表部分**。虚拟机栈是由一个个栈帧组成，而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法出口信息。

4. 局部变量表主要存放了**编译器可知的各种数据类型(基本类型)**和**对象引用(reference类型，指针 or 句柄)**。

5. Java虚拟机栈会出现两种异常：**StackOverFlowError**和**OutOfMemoryError**。

   - StackOverFlowError：若Java虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前Java虚拟机栈的最大深度的时候，就抛出此异常。
   - OutOfMemoryError：若Java虚拟机栈的内存大小允许动态扩展，且当线程请求栈时内存用完了，无法再动态扩展了，此时抛出OutOfMemoryError异常。

6. 本地方法栈和虚拟机栈的区别：**虚拟机栈为虚拟机执行Java方法(也就是字节码)服务**，而**本地方法栈则为虚拟机使用到的Native方法服务**。在HotSpot虚拟机中和Java虚拟机栈合二为一。

   也会出现**StackOverFlowError**和**OutOfMemoryError**两种异常。

7. Java**堆**是所有线程共享的一块内存区域，在虚拟机启动时创建。**此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存**。

   Java堆是垃圾收集器管理的主要区域